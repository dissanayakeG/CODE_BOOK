*Variables*
`val abc: Int = 6;`

- Val cannot be reassigned


```kotlin
    fun main() {
        var abc: Int = 6;
        abc = 7;
        println("Hello, $abc")
        println("Hello, ${abc-1}")
    }
```
*Function return type*
```kotlin
    fun birthdayGreeting(): Unit {} 
    //when return type is Unit it means return nothing(like void)
```

```kotlin
    fun main() {
        println(birthdayGreeting("Rover"))
    }

    fun birthdayGreeting(name: String): String {
        val nameGreeting = "Happy Birthday, $name!"
        val ageGreeting = "You are now 5 years old!"
        return "$nameGreeting\n$ageGreeting"
}
```

Unlike in some languages, such as Java, where a function can change the value passed into a parameter, parameters in Kotlin are immutable. You cannot reassign the value of a parameter from within the function body.

- birthdayGreeting(name = "Rex", age = 2) // Named arguments

Android Studio with Kotlin
--------------------------

create a empty composable app
-----------------------------
- onCreate is the entry point(like main in kotlin/c/c++)
- setContent help to set app layout
- Composable app can call Composable functions (start with @Composable)
- Composable functions has no return values. only showup some values

*printng a text* 
- Text(text = "Hello $name!")

- Add background(Alt+Enter ->Surround with widget->surrount with container ex: Box,Surface)

- Add padding Text(text = "Hi, my name is $name!", modifier = Modifier.padding(24.dp))

Classes and Object in Kotlin
----------------------------

```kotlin
    fun main() {
        val myFirstDice = Dice(6)
        println("Your ${myFirstDice.numSides} sided dice rolled ${myFirstDice.roll()}!")
        
        val mySecondDice = Dice(20)
        println("Your ${mySecondDice.numSides} sided dice rolled ${mySecondDice.roll()}!")
    }

    class Dice (val numSides: Int) {

        fun roll(): Int {
            return (1..numSides).random()
        }
    }
```

Button Click
------------

```kotlin
    val rollButton: Button = findViewById(R.id.button)

    // "button" is id of button, check on tree view
    rollButton.setOnClickListener {
        val toast = Toast.makeText(this, "Some Text", Toast.LENGTH_SHORT)
        toast.show();
                
        val resultTextView: TextView = findViewById(R.id.textView)
        // textView is id of textView, check on tree view
        resultTextView.text = "6"
        
        rollDice()
        
        private fun rollDice() {
            val dice = Dice(6)
            val diceRoll = dice.roll()
            val resultTextView: TextView = findViewById(R.id.textView);
            resultTextView.text = diceRoll.toString();
        }
    }

    class Dice(private val numSides: Int) {
        fun roll(): Int {
            return (1..numSides).random();
        }
    }
```

when statement
--------------

```kotlin
    fun main() {
        val myFirstDice = Dice(6)
        val rollResult = myFirstDice.roll()
        val luckyNumber = 4

        when (rollResult) {
            luckyNumber -> println("You won!")
            1 -> println("So sorry! You rolled a 1. Try again!")
            2 -> println("Sadly, you rolled a 2. Try again!")
            3 -> println("Unfortunately, you rolled a 3. Try again!")
            5 -> println("Don't cry! You rolled a 5. Try again!")
            6 -> println("Apologies! You rolled a 6. Try again!")
        }
}
```

- findViewByID is not better way to get elements when UI is more complex,
so view binding can be used

- need to enable it from app's `build.gradle file ( Gradle Scripts > build.gradle (Module: Tip_Time.app) )`

```kotlin
    buildFeatures {
        viewBinding = true
    }
```

- click sync now

*mainActivity class replace with*

```kotlin
    class MainActivity : AppCompatActivity() {

        lateinit var binding: ActivityMainBinding

        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            binding = ActivityMainBinding.inflate(layoutInflater)
            setContentView(binding.root)
        }
    }

    val myButton: Button = findViewById(R.id.my_button)
    myButton.text = "A button"

    // Better way with view binding
    val myButton: Button = binding.myButton
    myButton.text = "A button"

    // Best way with view binding and no extra variable
    binding.myButton.text = "A button"
```

*Note: The name of the binding class is generated by converting the name of the XML file to Pascal case and adding the word "Binding" to the end. Similarly, the reference for each view is generated by removing underscores and converting the view name to camel case. For example, in Pascal case activity_main.xml becomes ActivityMainBinding, and you can access @id/text_view as binding.textView.*

List and scrollView
-------------------

- Read-only list: List cannot be modified after you create it.
**type: listOf()

```kotlin
fun main() {
    //val numbers: List<Int> = listOf(1, 2, 3, 4, 5, 6)
    val numbers = listOf(1, 2, 3, 4, 5, 6)
    println("List: $numbers")
    println("Size: ${numbers.size}")

    // Access elements of the list
    println("First element: ${numbers[0]}")
    println("Second element: ${numbers[1]}")
    println("Last index: ${numbers.size - 1}")
    println("Last element: ${numbers[numbers.size - 1]}")
    println("First: ${numbers.first()}")
    println("Last: ${numbers.last()}")

    // Use the contains() method
    println("Contains 4? ${numbers.contains(4)}")
    println("Contains 7? ${numbers.contains(7)}")
    
    println("Reversed list: ${colors.reversed()}")
    println("List: $colors")
    println("Sorted list: ${colors.sorted()}")
}
```
- Mutable list: MutableList can be modified after you create it, meaning you can add, remove, or update its elements.
**type: mutableListof()

```
    val entrees = mutableListOf<String>()
    //or
    val entrees: MutableList<String> = mutableListOf()
```

- add one element - `entrees.add("noodles")`
- add more elements -  `val moreItems = listOf("ravioli", "lasagna", "fettuccine")`
			           `entrees.addAll(moreItems)`			
- remove element - `entrees.remove("spaghetti")` / `entrees.removeAt(0)` //0 is index
- clear list - `entrees.clear()`
- is empty check - `entrees.isEmpty()`

Loops
-----
while
-----
```kotlin
    val guestsPerFamily = listOf(2, 4, 1, 3)
    var totalGuests = 0
    var index = 0
    while (index < guestsPerFamily.size) {
        totalGuests += guestsPerFamily[index]
        index++
    }
    println("Total Guest Count: $totalGuests")
```
For
---
- for loop is easy and faster

```kotlin
    val names = listOf("Jessica", "Henry", "Alicia", "Jose")
    for (name in names) {
        println("$name - Number of characters: ${name.length}")
    }

    for (item in list) print(item) // Iterate over items in a list

    for (item in 'b'..'g') print(item) // Range of characters in an alphabet

    for (item in 1..5) print(item) // Range of numbers

    for (item in 5 downTo 1) print(item) // Going backward

    for (item in 3..6 step 2) print(item) // Prints: 35
```

















